
# Copyright 2010 Ramon Xuriguera
#
# This file is part of BibtexIndexMaker. 
#
# BibtexIndexMaker is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# BibtexIndexMaker is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with BibtexIndexMaker. If not, see <http://www.gnu.org/licenses/>.

import re
import simplejson #@UnresolvedImport

from bibim import log
from bibim.ie.types import (Example,
                            Wrapper)


MULTI_VALUE_WRAPPER_MIN_CORRECT = 0.2


class TooFewExamplesError(Exception):
    pass


class WrapperTrainer(object):
    """
    This class generates wrappers that cover a given set of examples and that
    use rules generated by a set of rulers. 
    """
    
    def __init__(self, rulers=[], num_examples=2):
        self.rulers = rulers
        self.num_examples = num_examples
        
    def get_rulers(self):
        return self.__rulers

    def get_num_examples(self):
        return self.__num_examples

    def set_rulers(self, value):
        self.__rulers = value

    def set_num_examples(self, value):
        self.__num_examples = value
        
    rulers = property(get_rulers, set_rulers)
    num_examples = property(get_num_examples, set_num_examples)     

    def train(self, examples):
        """
        Generates all the possible wrappers that cover the given examples.
        
        The content of the examples must be compatible with the input type
        of the first of the rules, i.e. if the first ruler expects a string, 
        the content attribute of the examples must be a string.
        """
        wrappers = []
        if len(examples) < self.num_examples:
            log.warn('Too few examples. Could not train wrappers') #@UndefinedVariable
            return wrappers
        rule_sets = self._get_rule_sets(list(self.rulers), examples)
        for rule_set in rule_sets:
            wrapper = Wrapper(rules=rule_set)
            self._evaluate_wrapper(wrapper, examples)
            wrappers.append(wrapper)
        log.debug('Trainer generated %d wrappers (not prunned)' % #@UndefinedVariable 
                  len(wrappers))
        return wrappers
     
    def _get_rule_sets(self, rulers, example_set):
        """
        Returns all the possible rule sets that can compose a wrapper for a 
        given example set.
        
        Rulers must be in the order should be applied as the output after 
        applying a rule will be used as the input of the next ruler.
        """
        if not len(rulers):
            return [[]]

        current_ruler = rulers.pop(0)
        new_rules = current_ruler.rule(example_set)
        new_rule_sets = []
        for rule in new_rules:
            current_example_set = self._get_new_example_set(rule, example_set)
            # Recursion to get all the possibilities
            rule_sets = self._get_rule_sets(list(rulers),
                                            current_example_set)
            map(lambda x: x.insert(0, rule), rule_sets)
            for rule_set in rule_sets:
                new_rule_sets.append(rule_set)
        return new_rule_sets

    def _get_new_example_set(self, rule, example_set):
        """
        Return a list of examples with the same value attribute as example_set
        but where the content is the result of applying rule.
        """
        new_example_set = []
        for example in example_set:
            value = example.value
            content = rule.apply(example.content)
            if value and content:
                new_example_set.append(Example(value, content))
            else:
                log.warn('Example content is None after applying rule')  #@UndefinedVariable
        return new_example_set

    def _evaluate_wrapper(self, wrapper, examples):
        """
        It applies the wrapper to all the available examples and checks if 
        it extracts the expected information. If so, it upvotes the wrapper,
        and downvotes otherwise.
        """
        for example in examples:
            log.debug('Evaluating wrapper with example value %s ' % #@UndefinedVariable
                      str(example.value)) 
            info = wrapper.extract_info(example.content)
            
            # Evaluate depending if the extracted information is one single
            # value or a collection.
            if not info:
                ev_result = False
            elif type(info) is list:
                ev_result = self._evaluate_multi_value_wrapper(info,
                                                               example.value)
            else:
                ev_result = self._evaluate_single_value_wrapper(info,
                                                                example.value)
            if ev_result:
                wrapper.upvotes += 1
            else:
                wrapper.downvotes += 1
            log.debug('Result of evaluation: %s' % str(ev_result)) #@UndefinedVariable
        
    def _evaluate_single_value_wrapper(self, info, value):
        if re.search(value, info):
            return True
        else:
            return False
    
    def _evaluate_multi_value_wrapper(self, info_list, values):
        correct = 0
        for info in info_list:
            # Values and extracted info may not be in the same order. Check
            # each piece of info against all the values
            for value in values:
                if re.search(value, simplejson.dumps(info)):
                    correct += 1
                    break
        return (correct >= len(values) * MULTI_VALUE_WRAPPER_MIN_CORRECT)

